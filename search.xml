<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/02.Docker/02.CentOS%20%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>微服务架构</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><h2 id="微服务架构的概念"><a href="#微服务架构的概念" class="headerlink" title="微服务架构的概念"></a>微服务架构的概念</h2><p>微服务架构是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。</p>
<p><strong>PS：</strong> 微服务这个概念是 2012 年出现的，作为加快 Web 和移动应用程序开发进程的一种方法，2014 年开始受到各方的关注，同年为微服务的元年；</p>
<h2 id="微服务的特征"><a href="#微服务的特征" class="headerlink" title="微服务的特征"></a>微服务的特征</h2><h3 id="官方的定义"><a href="#官方的定义" class="headerlink" title="官方的定义"></a>官方的定义</h3><ul>
<li>一系列的独立的服务共同组成系统</li>
<li>单独部署，跑在自己的进程中</li>
<li>每个服务为独立的业务开发</li>
<li>分布式管理</li>
<li>非常强调隔离性</li>
</ul>
<h3 id="大概的标准"><a href="#大概的标准" class="headerlink" title="大概的标准"></a>大概的标准</h3><ul>
<li>分布式服务组成的系统</li>
<li>按照业务，而不是技术来划分组织</li>
<li>做有生命的产品而不是项目</li>
<li>强服务个体和弱通信（ Smart endpoints and dumb pipes ）</li>
<li>自动化运维（ DevOps ）</li>
<li>高度容错性</li>
<li>快速演化和迭代</li>
</ul>
<h2 id="SOA-架构与微服务架构的区别"><a href="#SOA-架构与微服务架构的区别" class="headerlink" title="SOA 架构与微服务架构的区别"></a>SOA 架构与微服务架构的区别</h2><h3 id="注重重用，微服务注重重写"><a href="#注重重用，微服务注重重写" class="headerlink" title="注重重用，微服务注重重写"></a>注重重用，微服务注重重写</h3><p>SOA 的主要目的是为了企业各个系统更加容易地融合在一起。</p>
<p>微服务通常由重写一个模块开始。要把整个巨石型的应用重写是有很大的风险的，也不一定必要。我们向微服务迁移的时候通常从耦合度最低的模块或对扩展性要求最高的模块开始。</p>
<p>把它们一个一个剥离出来用敏捷地重写，可以尝试最新的技术和语言和框架，然后 <strong>单独布署</strong>。它通常不依赖其他服务。微服务中常用的 <code>API Gateway</code> 的模式主要目的也不是重用代码。</p>
<p>而是减少客户端和服务间的往来。<code>API gateway</code> 模式不等同与 <code>Facade</code> 模式，我们可以使用如 <code>Future</code>之类的调用，甚至返回不完整数据。</p>
<h3 id="注重水平服务，微服务注重垂直服务"><a href="#注重水平服务，微服务注重垂直服务" class="headerlink" title="注重水平服务，微服务注重垂直服务"></a>注重水平服务，微服务注重垂直服务</h3><p>SOA 设计喜欢给服务分层(如 Service Layers 模式)。我们常常见到一个 Entity 服务层的设计，美其名曰 Data Access Layer。这种设计要求所有的服务都通过这个 Entity 服务层。来获取数据。这种设计非常不灵活，比如每次数据层的改动都可能影响到所有业务层的服务。而每个微服务通常有它自己独立的 Data Store。我们在拆分数据库时可以适当的做些去范式化，让它不需要依赖其他服务的数据。</p>
<p>微服务通常是直接面对用户的，每个微服务通常直接为用户提供某个功能。类似的功能可能针对手机有一个服务，针对机顶盒是另外一个服务。在 SOA 设计模式中这种情况通常会用到 <code>Multi-ChannelEndpoint</code>的模式返回一个大而全的结果兼顾到所有的客户端的需求。</p>
<h3 id="注重自上而下，微服务注重自下而上"><a href="#注重自上而下，微服务注重自下而上" class="headerlink" title="注重自上而下，微服务注重自下而上"></a>注重自上而下，微服务注重自下而上</h3><p>SOA 架构在设计开始时会先定义好服务合同。它喜欢集中管理所有的服务，包括集中管理业务逻辑，数据，流程，Schema 等。它使用 Enterprise Inventory 和 Service Composition 等方法来集中管理服务。SOA 架构通常会预先把每个模块服务接口都定义好。模块系统间的通讯必须遵守这些接口，各服务是针对他们的调用者。</p>
<p>SOA 架构适用于 TO GAF 之类的架构方法论。</p>
<p>微服务则敏捷得多。只要用户用得到，就先把这个服务挖出来。然后针对性的，快速确认业务需求，快速开发迭代。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>微服务与 SOA 有很多相同之处。两者都属于典型的、包含松耦合分布式组件的系统结构。在围绕着服务的概念创建架构这一方面，微服务提供了一种更清晰、定义更良好的方式。微服务的原则与敏捷软件开发思想是高度一致的，而它与 SOA 原则的演化的目标也是相同的，则减少传统的企业服务总线开发的高复杂性。两者之间最关键的区别在于，微服务专注于以自治的方式产生价值。但是两种架构背后的意图是不同的：SOA 尝试将应用集成，一般采用中央管理模式来确保各应用能够交互运作。微服务尝试部署新功能，快速有效地扩展开发团队。它着重于分散管理、代码再利用与自动化执行。</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">SOA</th>
<th align="left">微服务</th>
</tr>
</thead>
<tbody><tr>
<td align="left">组件大小</td>
<td align="left">大块业务逻辑</td>
<td align="left">单独任务或小块业务逻辑</td>
</tr>
<tr>
<td align="left">耦合</td>
<td align="left">通常松耦合</td>
<td align="left">总是松耦合</td>
</tr>
<tr>
<td align="left">公司架构</td>
<td align="left">任何类型</td>
<td align="left">小型、专注于功能交叉的团队</td>
</tr>
<tr>
<td align="left">管理</td>
<td align="left">着重中央管理</td>
<td align="left">着重分散管理</td>
</tr>
<tr>
<td align="left">目标</td>
<td align="left">确保应用能够交互操作</td>
<td align="left">执行新功能，快速拓展开发团队</td>
</tr>
</tbody></table>
<p>微服务并不是一种新思想的方法。它更像是一种思想的精炼，一种 SOA 的精细化演进，并且更好地利用了先进的技术以解决问题，例如容器与自动化等。所以对于我们去选择服务技术框架时，并不是非黑即白，而是针对 SOA、MSA 两种架构设计同时要考虑到兼容性，对于现有平台情况架构设计，退则守 SOA，进则攻 MSA，阶段性选择适合的。</p>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>分布式技术</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>有效的拆分应用，实现敏捷开发和部署</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\Lusifer2018052805390002.png" alt="img"></p>
<h4 id="开发和交付中的伸缩立方"><a href="#开发和交付中的伸缩立方" class="headerlink" title="开发和交付中的伸缩立方"></a>开发和交付中的伸缩立方</h4><p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\0714fcab4f6d5951014e5613657c8289.png" alt="img"></p>
<p><strong>X轴：</strong> 运行多个负载均衡器之后的运行实例 <strong>Y轴：</strong> 将应用进一步分解为微服务（分库） <strong>Z轴：</strong> 大数据量时，将服务分区（分表）</p>
<h2 id="官方的定义"><a href="#官方的定义" class="headerlink" title="官方的定义"></a>官方的定义</h2><ul>
<li>一系列的独立的服务共同组成系统</li>
<li>单独部署，跑在自己的进程中</li>
<li>每个服务为独立的业务开发</li>
<li>分布式管理</li>
<li>非常强调隔离性</li>
</ul>
<h2 id="大概的标准"><a href="#大概的标准" class="headerlink" title="大概的标准"></a>大概的标准</h2><ul>
<li>分布式服务组成的系统</li>
<li>按照业务，而不是技术来划分组织</li>
<li>做有生命的产品而不是项目</li>
<li>强服务个体和弱通信（ Smart endpoints and dumb pipes ）</li>
<li>自动化运维（ DevOps ）</li>
<li>高度容错性</li>
<li>快速演化和迭代</li>
</ul>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>分布式技术</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务的问题与解决方案</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/04.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="微服务的问题与解决方案"><a href="#微服务的问题与解决方案" class="headerlink" title="微服务的问题与解决方案"></a>微服务的问题与解决方案</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>要实际的应用微服务，需要解决以下问题：</p>
<ul>
<li>客户端如何访问这些服务</li>
<li>每个服务之间如何通信</li>
<li>如此多的服务，如何实现？</li>
<li>服务挂了，如何解决？（备份方案，应急处理机制）</li>
</ul>
<h3 id="客户端如何访问这些服务"><a href="#客户端如何访问这些服务" class="headerlink" title="客户端如何访问这些服务"></a>客户端如何访问这些服务</h3><p>原来的 Monolithic 方式开发，所有的服务都是本地的，UI 可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java 进程了。客户端 UI 如何访问他？</p>
<p>后台有 N 个服务，前台就需要记住管理 N 个服务，一个服务 <strong>下线</strong>、<strong>更新</strong>、<strong>升级</strong>，前台就要重新部署，这明显不服务我们拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。</p>
<p>另外，N 个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。</p>
<p>所以，一般在后台 N 个服务和 UI 之间一般会一个代理或者叫 <code>API Gateway</code>，他的作用包括：</p>
<ul>
<li>提供统一服务入口，让微服务对前台透明</li>
<li>聚合后台的服务，节省流量，提升性能</li>
<li>提供安全，过滤，流控等API管理功能</li>
</ul>
<p>其实这个 <code>API Gateway</code> 可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的 MVC 框架，甚至是一个 <code>Node.js</code> 的服务端。他们最重要的作用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过 <code>API Gateway</code> 也有可能成为 <strong>单点故障</strong>点或者性能的瓶颈。</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\Lusifer2018052805390003.png" alt="img"></p>
<h3 id="每个服务之间如何通信"><a href="#每个服务之间如何通信" class="headerlink" title="每个服务之间如何通信"></a>每个服务之间如何通信</h3><p>所有的微服务都是独立的 Java 进程跑在独立的虚拟机上，所以服务间的通信就是 IPC（Inter Process Communication），已经有很多成熟的方案。现在基本最通用的有两种方式：</p>
<h4 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h4><ul>
<li>REST（JAX-RS，Spring Boot）</li>
<li>RPC（Thrift, Dubbo）</li>
</ul>
<p>同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。一般 REST 基于 HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了 HTTP 的 SDK 就能调用，所以相对使用的广一些。RPC 也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。</p>
<h4 id="异步消息调用"><a href="#异步消息调用" class="headerlink" title="异步消息调用"></a>异步消息调用</h4><ul>
<li>Kafka</li>
<li>Notify</li>
<li>MessageQueue</li>
</ul>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\Lusifer2018052805390004.png" alt="img"></p>
<p>异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据 <strong>最终一致性</strong>；还有就是后台服务一般要实现 <strong>幂等性</strong>，因为消息送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的 <code>Broker</code></p>
<h3 id="如此多的服务，如何实现？"><a href="#如此多的服务，如何实现？" class="headerlink" title="如此多的服务，如何实现？"></a>如此多的服务，如何实现？</h3><p>在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？</p>
<p>这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过 Zookeeper 等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到 ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过 ZK 寻址，根据可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK 会发通知给服务客户端。</p>
<h4 id="基于客户端的服务注册与发现"><a href="#基于客户端的服务注册与发现" class="headerlink" title="基于客户端的服务注册与发现"></a>基于客户端的服务注册与发现</h4><p>优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如 Dubbo。</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\Lusifer2018052805390005.png" alt="img"></p>
<h4 id="基于服务端的服务注册与发现"><a href="#基于服务端的服务注册与发现" class="headerlink" title="基于服务端的服务注册与发现"></a>基于服务端的服务注册与发现</h4><p>优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\Lusifer2018052805390006.png" alt="img"></p>
<h4 id="服务挂了，如何解决？"><a href="#服务挂了，如何解决？" class="headerlink" title="服务挂了，如何解决？"></a>服务挂了，如何解决？</h4><p>前面提到，Monolithic 方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。相应的手段有很多：</p>
<ul>
<li>重试机制</li>
<li>限流</li>
<li>熔断机制</li>
<li>负载均衡</li>
<li>降级（本地缓存）</li>
</ul>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>分布式技术</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构设计模式</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/05.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="微服务架构设计模式"><a href="#微服务架构设计模式" class="headerlink" title="微服务架构设计模式"></a>微服务架构设计模式</h2><h3 id="微服务架构需要考虑的问题"><a href="#微服务架构需要考虑的问题" class="headerlink" title="微服务架构需要考虑的问题"></a>微服务架构需要考虑的问题</h3><ul>
<li>API Gateway</li>
<li>服务间调用</li>
<li>服务发现</li>
<li>服务容错</li>
<li>服务部署</li>
<li>数据调用</li>
</ul>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\983980-20170501200932257-1866725509.png" alt="img"></p>
<h3 id="聚合器微服务设计模式"><a href="#聚合器微服务设计模式" class="headerlink" title="聚合器微服务设计模式"></a>聚合器微服务设计模式</h3><p>这是一种最常见也最简单的设计模式</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\983980-20170501201000148-1677353522.png" alt="img"></p>
<p>聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的 WEB 页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合 <strong>DRY</strong> 原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿 <code>X轴</code> 和 <code>Z轴</code> 独立扩展。</p>
<h3 id="代理微服务设计模式"><a href="#代理微服务设计模式" class="headerlink" title="代理微服务设计模式"></a>代理微服务设计模式</h3><p>这是聚合模式的一个变种，如下图所示</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\983980-20170501201046898-281749162.png" alt="img"></p>
<p>在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。</p>
<h3 id="链式微服务设计模式"><a href="#链式微服务设计模式" class="headerlink" title="链式微服务设计模式"></a>链式微服务设计模式</h3><p>这种模式在接收到请求后会产生一个经过合并的响应，如下图所示</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\983980-20170501201150117-1722000003.png" alt="img"></p>
<p>在这种情况下，<code>服务A</code> 接收到请求后会与 <code>服务B</code> 进行通信，类似地，<code>服务B</code> 会同 <code>服务C</code> 进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待。</p>
<h3 id="分支微服务设计模式"><a href="#分支微服务设计模式" class="headerlink" title="分支微服务设计模式"></a>分支微服务设计模式</h3><p>这种模式是聚合器模式的扩展，允许同时调用两个微服务链，如下图所示</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\983980-20170501201226507-2146929767.png" alt="img"></p>
<h3 id="数据共享微服务设计模式"><a href="#数据共享微服务设计模式" class="headerlink" title="数据共享微服务设计模式"></a>数据共享微服务设计模式</h3><p>自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（Monolithic Application）”时，SQL 数据库反规范化可能会导致数据重复和不一致。因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，如下图所示</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\983980-20170501201353945-1013665174.png" alt="img"></p>
<p>在这种情况下，部分微服务可能会共享缓存和数据库存储。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。</p>
<h3 id="异步消息传递微服务设计模式"><a href="#异步消息传递微服务设计模式" class="headerlink" title="异步消息传递微服务设计模式"></a>异步消息传递微服务设计模式</h3><p>虽然 REST 设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替 REST 请求/响应，如下图所示</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\983980-20170501201415054-327655979.png" alt="img"></p>
<h2 id="新架构新起点"><a href="#新架构新起点" class="headerlink" title="新架构新起点"></a>新架构新起点</h2><p>对于微服务架构，最重要的是思维上的转变，技术不是问题，思想才是王道（有道无术，术尚可求，有术无道，止于术）</p>
<p>对于做微服务开发的几点建议：</p>
<ul>
<li>应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）</li>
<li>做有生命的产品，而不是项目</li>
<li>全栈化</li>
<li>后台服务贯彻 Single Responsibility Principle（单一职责原则）</li>
<li>VM -&gt; Docker</li>
<li>DevOps</li>
</ul>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>分布式技术</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>传统架构与微服务架构的区别</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/02.%E4%BC%A0%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="传统架构与微服务架构的区别"><a href="#传统架构与微服务架构的区别" class="headerlink" title="传统架构与微服务架构的区别"></a>传统架构与微服务架构的区别</h2><h3 id="系统架构需要遵循的三个标准"><a href="#系统架构需要遵循的三个标准" class="headerlink" title="系统架构需要遵循的三个标准"></a>系统架构需要遵循的三个标准</h3><ul>
<li>提高敏捷性：及时响应业务需求，促进企业发展</li>
<li>提升用户体验：提升用户体验，减少用户流失</li>
<li>降低成本：降低增加产品、客户或业务方案的成本</li>
</ul>
<h3 id="传统的开发模式"><a href="#传统的开发模式" class="headerlink" title="传统的开发模式"></a>传统的开发模式</h3><p>先来看看传统的 WEB 开发方式，通过对比比较容易理解什么是 <strong>微服务架构</strong>。和 <strong>微服务</strong> 相对应的，这种方式一般被称为 <strong>单体式开发（Monolithic）</strong>。</p>
<p>既所有的功能打包在一个 WAR 包里，基本没有外部依赖（除了容器），部署在一个 JavaEE 容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI 等所有逻辑。</p>
<p><img src="D:\学习资料\微服务学习笔记\00.基础技术\04.Nexus\assets\Lusifer2018052805390001.png" alt="img"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>开发简单，集中式管理</li>
<li>基本不会重复开发</li>
<li>功能都在本地，没有分布式的管理和调用消耗</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>效率低：开发都在同一个项目改代码，相互等待，冲突不断</li>
<li>维护难：代码功功能耦合在一起，新人不知道何从下手</li>
<li>不灵活：构建时间长，任何小修改都要重构整个项目，耗时</li>
<li>稳定性差：一个微小的问题，都可能导致整个应用挂掉</li>
<li>扩展性不够：无法满足高并发下的业务需求</li>
</ul>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>分布式技术</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 简介</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/02.SpringBoot/01.SpringBoot/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="Spring-简史"><a href="#Spring-简史" class="headerlink" title="Spring 简史"></a>Spring 简史</h2><h3 id="Spring-1-x-时代"><a href="#Spring-1-x-时代" class="headerlink" title="Spring 1.x 时代"></a>Spring 1.x 时代</h3><p>在 Spring1.x 时代，都是通过 xml 文件配置 bean，随着项目的不断扩大，需要将 xml 配置分放到不同的配置文件中，需要频繁的在 java 类和 xml 配置文件中切换。</p>
<h3 id="Spring-2-x-时代"><a href="#Spring-2-x-时代" class="headerlink" title="Spring 2.x 时代"></a>Spring 2.x 时代</h3><p>随着 JDK 1.5 带来的注解支持，Spring2.x 可以使用注解对 Bean 进行申明和注入，大大的减少了 xml 配置文件，同时也大大简化了项目的开发。</p>
<p>那么，问题来了，究竟是应该使用 xml 还是注解呢？</p>
<p>最佳实践：</p>
<ul>
<li>应用的基本配置用 xml，比如：数据源、资源文件等</li>
<li>业务开发用注解，比如：Service 中注入 bean 等</li>
</ul>
<h3 id="Spring-3-x-时代"><a href="#Spring-3-x-时代" class="headerlink" title="Spring 3.x 时代"></a>Spring 3.x 时代</h3><p>从 Spring3.x 开始提供了 Java 配置方式，使用 Java 配置方式可以更好的理解你配置的 Bean，现在我们就处于这个时代，并且 Spring4.x 和 Spring boot 都推荐使用 java 配置的方式。</p>
<h3 id="Spring-5-x-时代"><a href="#Spring-5-x-时代" class="headerlink" title="Spring 5.x 时代"></a>Spring 5.x 时代</h3><p>Spring5.x 是 Java 界首个支持响应式的 Web 框架，是 Spring 的一个重要版本，距离 Spring4.x 差不多四年。在此期间，大多数增强都是在 SpringBoot 项目中完成的，其最大的亮点就是提供了完整的端到端响应式编程的支持（新增 Spring WebFlux 模块）。</p>
<p>Spring WebFlux 同时支持使用旧的 Spring MVC 注解声明 <code>Reactive Controller</code>。和传统的 <code>MVC Controller</code> 不同，<code>Reactive Controller</code> 操作的是 <strong>非阻塞</strong> 的 <code>ServerHttpRequest</code> 和 <code>ServerHttpResponse</code>，而不再是 Spring MVC 里的 HttpServletRequest 和 HttpServletResponse。</p>
<p>至此也代表着 Java 正式迎来了响应式异步编程的时代。</p>
<h2 id="Spring-Boot-简介"><a href="#Spring-Boot-简介" class="headerlink" title="Spring Boot 简介"></a>Spring Boot 简介</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>随着动态语言的流行 (Ruby、Groovy、Scala、Node.js)，Java 的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。</p>
<p>在上述环境下，Spring Boot 应运而生。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速的运行起来。使用 Spring Boot 很容易创建一个独立运行（运行 Jar，内嵌 Servlet 容器）准生产级别的基于 Spring 框架的项目，使用 Spring Boot 你可以不用或者只需很少的 Spring 配置。</p>
<h2 id="Spring-Boot-优缺点"><a href="#Spring-Boot-优缺点" class="headerlink" title="Spring Boot 优缺点"></a>Spring Boot 优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>快速构建项目</li>
<li>对主流开发框架的无配置集成</li>
<li>项目可独立运行，无需外部依赖 Servlet 容器</li>
<li>提供运行时的应用监控</li>
<li>极大地提高了开发、部署效率</li>
<li>与云计算的天然集成</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>版本迭代速度很快，一些模块改动很大</li>
<li>由于不用自己做配置，报错时很难定位</li>
<li>网上现成的解决方案比较少</li>
</ul>
<h2 id="第一个-Spring-Boot-应用程序"><a href="#第一个-Spring-Boot-应用程序" class="headerlink" title="第一个 Spring Boot 应用程序"></a>第一个 Spring Boot 应用程序</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>这里我们使用 Intellij IDEA 来新建一个 Spring Boot 项目。</p>
<h4 id="打开-IDEA-gt-New-Project-gt-Spring-Initializr"><a href="#打开-IDEA-gt-New-Project-gt-Spring-Initializr" class="headerlink" title="打开 IDEA -&gt; New Project -&gt; Spring Initializr"></a>打开 IDEA -&gt; New Project -&gt; Spring Initializr</h4><p><img src="D:\学习资料\微服务学习笔记\02.SpringBoot\assets\Lusifer1527230830.png" alt="img"></p>
<h4 id="填写项目信息"><a href="#填写项目信息" class="headerlink" title="填写项目信息"></a>填写项目信息</h4><p><img src="D:\学习资料\微服务学习笔记\02.SpringBoot\assets\Lusifer1527231009.png" alt="img"></p>
<h4 id="选择-Spring-Boot-版本及-Web-开发所需的依赖"><a href="#选择-Spring-Boot-版本及-Web-开发所需的依赖" class="headerlink" title="选择 Spring Boot 版本及 Web 开发所需的依赖"></a>选择 Spring Boot 版本及 Web 开发所需的依赖</h4><p><img src="https://www.funtl.com/assets/Lusifer1527231053.png" alt="img"></p>
<h4 id="保存项目到指定目录"><a href="#保存项目到指定目录" class="headerlink" title="保存项目到指定目录"></a>保存项目到指定目录</h4><p><img src="https://www.funtl.com/assets/Lusifer1527231065.png" alt="img"></p>
<h4 id="工程目录结构"><a href="#工程目录结构" class="headerlink" title="工程目录结构"></a>工程目录结构</h4><p>创建完成后的工程目录结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">│  .gitignore</span><br><span class="line">│  pom.xml</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    ├─main</span><br><span class="line">    │  ├─java</span><br><span class="line">    │  │  └─com</span><br><span class="line">    │  │      └─funtl</span><br><span class="line">    │  │          └─hello</span><br><span class="line">    │  │              └─spring</span><br><span class="line">    │  │                  └─boot</span><br><span class="line">    │  │                          HelloSpringBootApplication.java</span><br><span class="line">    │  │</span><br><span class="line">    │  └─resources</span><br><span class="line">    │      │  application.properties</span><br><span class="line">    │      │</span><br><span class="line">    │      ├─static</span><br><span class="line">    │      └─templates</span><br><span class="line">    └─test</span><br><span class="line">        └─java</span><br><span class="line">            └─com</span><br><span class="line">                └─funtl</span><br><span class="line">                    └─hello</span><br><span class="line">                        └─spring</span><br><span class="line">                            └─boot</span><br><span class="line">                                    HelloSpringBootApplicationTests.java</span><br></pre></td></tr></table></figure>


<ul>
<li>.gitignore：Git 过滤配置文件</li>
<li>pom.xml：Maven 的依赖管理配置文件</li>
<li>HelloSpringBootApplication.java：程序入口</li>
<li>resources：资源文件目录<ul>
<li>static: 静态资源文件目录</li>
<li>templates：模板资源文件目录</li>
<li>application.properties：Spring Boot 的配置文件，实际开发中会替换成 YAML 语言配置（application.yml）</li>
</ul>
</li>
</ul>
<h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.funtl&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hello-spring-boot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;hello-spring-boot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>


<ul>
<li>parent：继承了 Spring Boot 的 Parent，表示我们是一个 Spring Boot 工程</li>
<li><code>spring-boot-starter-web</code>：包含了 <code>spring-boot-starter</code> 还自动帮我们开启了 Web 支持</li>
</ul>
<h3 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h3><p>我们创建一个 Controller 来演示一下 Spring Boot 的神奇功能</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package com.funtl.hello.spring.boot.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;&quot;, method = RequestMethod.GET)</span><br><span class="line">    public String sayHi() &#123;</span><br><span class="line">        return &quot;Hello Spring Boot&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>启动 <code>HelloSpringBootApplication</code> 的 <code>main()</code> 方法，浏览器访问 <a href="http://localhost:8080/">http://localhost:8080</a> 可以看到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hello Spring Boot</span><br></pre></td></tr></table></figure>


<h3 id="神奇之处"><a href="#神奇之处" class="headerlink" title="神奇之处"></a>神奇之处</h3><ul>
<li>没有配置 web.xml</li>
<li>没有配置 application.xml，Spring Boot 帮你配置了</li>
<li>没有配置 application-mvc.xml，Spring Boot 帮你配置了</li>
<li>没有配置 Tomcat，Spring Boot 内嵌了 Tomcat 容器</li>
</ul>
<h2 id="Spring-Boot-单元测试"><a href="#Spring-Boot-单元测试" class="headerlink" title="Spring Boot 单元测试"></a>Spring Boot 单元测试</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>主要是通过 <code>@RunWith</code> 和 <code>@SpringBootTest</code> 注解来开启单元测试功能</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package com.funtl.hello.spring.boot;</span><br><span class="line"></span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line">import org.springframework.boot.web.server.LocalServerPort;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">import static org.hamcrest.CoreMatchers.equalTo;</span><br><span class="line">import static org.junit.Assert.assertThat;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = HelloSpringBootApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line">public class HelloSpringBootApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @LocalServerPort</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    private URL base;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        this.base = new URL(&quot;http://localhost:&quot; + port + &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(), String.class);</span><br><span class="line">        assertThat(response.getBody(), equalTo(&quot;Hello Spring Boot&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行它会先启动 Spring Boot 工程，再启动单元测试</p>
<h2 id="Spring-Boot-常用配置"><a href="#Spring-Boot-常用配置" class="headerlink" title="Spring Boot 常用配置"></a>Spring Boot 常用配置</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>本章节主要介绍一下 Spring Boot 中的一些常用配置，比如：自定义 Banner、配置日志、关闭特定的自动配置等。</p>
<h3 id="自定义-Banner"><a href="#自定义-Banner" class="headerlink" title="自定义 Banner"></a>自定义 Banner</h3><p>在 Spring Boot 启动的时候会有一个默认的启动图案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> &#x2F;\\ &#x2F; ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#39;_ | &#39;_| | &#39;_ \&#x2F; _&#96; | \ \ \ \</span><br><span class="line"> \\&#x2F;  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#39;  |____| .__|_| |_|_| |_\__, | &#x2F; &#x2F; &#x2F; &#x2F;</span><br><span class="line"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F;</span><br><span class="line"> :: Spring Boot ::        (v1.5.8.RELEASE)</span><br></pre></td></tr></table></figure>
<p>我们在 <code>src/main/resources</code> 目录下新建一个 banner.txt</p>
<p>通过 <a href="http://patorjk.com/software/taag">http://patorjk.com/software/taag</a> 网站生成字符串，将网站生成的字符复制到 banner.txt 中</p>
<p>再次运行这个程序</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br><span class="line">//                          _ooOoo_                               //</span><br><span class="line">//                         o8888888o                              //</span><br><span class="line">//                         88&quot; . &quot;88                              //</span><br><span class="line">//                         (| ^_^ |)                              //</span><br><span class="line">//                         O\  =  /O                              //</span><br><span class="line">//                      ____/`---&#x27;\____                           //</span><br><span class="line">//                    .&#x27;  \\|     |//  `.                         //</span><br><span class="line">//                   /  \\|||  :  |||//  \                        //</span><br><span class="line">//                  /  _||||| -:- |||||-  \                       //</span><br><span class="line">//                  |   | \\\  -  /// |   |                       //</span><br><span class="line">//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //</span><br><span class="line">//                  \  .-\__  `-`  ___/-. /                       //</span><br><span class="line">//                ___`. .&#x27;  /--.--\  `. . ___                     //</span><br><span class="line">//              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //</span><br><span class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</span><br><span class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</span><br><span class="line">//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //</span><br><span class="line">//                           `=---=&#x27;                              //</span><br><span class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</span><br><span class="line">//            佛祖保佑       永不宕机     永无BUG                  //</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br></pre></td></tr></table></figure>


<p>常用属性设置：</p>
<ul>
<li><code>$&#123;AnsiColor.BRIGHT_RED&#125;</code>：设置控制台中输出内容的颜色</li>
<li><code>$&#123;application.version&#125;</code>：用来获取 <code>MANIFEST.MF</code> 文件中的版本号</li>
<li><code>$&#123;application.formatted-version&#125;</code>：格式化后的 <code>$&#123;application.version&#125;</code> 版本信息</li>
<li><code>$&#123;spring-boot.version&#125;</code>：Spring Boot 的版本号</li>
<li><code>$&#123;spring-boot.formatted-version&#125;</code>：格式化后的 <code>$&#123;spring-boot.version&#125;</code> 版本信息</li>
</ul>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Spring Boot 项目使用一个全局的配置文件 <code>application.properties</code> 或者是 <code>application.yml</code>，在 <code>resources</code> 目录下或者类路径下的 <code>/config</code> 下，一般我们放到 <code>resources</code> 下。</p>
<p>修改 Tomcat 的端口为 9090，并将默认的访问路径 “/“ 修改为 “boot”，可以在 <code>application.properties</code>中添加：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">server.port=9090</span><br><span class="line">server.context-path=/boot</span><br></pre></td></tr></table></figure>


<p>或在 application.yml 中添加：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9090</span><br><span class="line">  context-path: /boot</span><br></pre></td></tr></table></figure>


<p>测试效果：</p>
<p><img src="D:\学习资料\微服务学习笔记\02.SpringBoot\assets\Lusifer1509896204.png" alt="img"></p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/html/common-application-properties.html">更多配置</a></p>
<h4 id="Starter-POM"><a href="#Starter-POM" class="headerlink" title="Starter POM"></a>Starter POM</h4><p>Spring Boot 为我们提供了简化企业级开发绝大多数场景的 starter pom ，只要使用了应用场景所需要的 starter pom ，相关的技术配置将会消除，就可以得到 Spring Boot 为我们提供的自动配置的 Bean。</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter">更多 Starter POM</a></p>
<h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>Spring Boot 对各种日志框架都做了支持，我们可以通过配置来修改默认的日志的配置</p>
<p>默认情况下，Spring Boot 使用 Logback 作为日志框架</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">../logs/spring-boot-hello.log</span></span><br><span class="line">  <span class="attr">level.org.springframework.web:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>


<h3 id="关闭特定的自动配置"><a href="#关闭特定的自动配置" class="headerlink" title="关闭特定的自动配置"></a>关闭特定的自动配置</h3><p>关闭特定的自动配置使用 <code>@SpringBootApplication</code> 注解的 <code>exclude</code> 参数即可，这里以关闭数据源的自动配置为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>分布式技术</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分布式技术</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/02.SpringBoot/0.%20Spring%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li><p>了解SpringBoot的作用</p>
</li>
<li><p>掌握java配置的方式</p>
</li>
<li><p>了解SpringBoot自动配置原理</p>
</li>
<li><p>掌握SpringBoot的基本使用</p>
</li>
</ul>
<h1 id="1-了解SpringBoot"><a href="#1-了解SpringBoot" class="headerlink" title="1.  了解SpringBoot"></a>1.  了解SpringBoot</h1><p>在这一部分，主要了解一下3个问题：</p>
<ul>
<li>什么是SpringBoot</li>
<li>为什么要学习SpringBoot</li>
<li>SpringBoot的特点</li>
</ul>
<h2 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1 什么是SpringBoot"></a>1.1 什么是SpringBoot</h2><p>SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework同属于spring的产品：</p>
<p><img src="C:\Users\wgw2330\AppData\Roaming\Typora\typora-user-images\1568631782645.png" alt="1568631782645"></p>
<p>可以看到一段介绍：</p>
<blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p>
<p>We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.</p>
</blockquote>
<p>翻译一下：</p>
<blockquote>
<p>用一些固定的方式来构建生产级别的spring应用。Spring Boot推崇约定大于配置的方式以便能够尽快的驱动并允许程序。</p>
</blockquote>
<p>其实把Spring Boot称为搭建程序的<!--脚手架-->。其最重要的作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。</p>
<h2 id="1-2-为什么要学习SpringBoot"><a href="#1-2-为什么要学习SpringBoot" class="headerlink" title="1.2 为什么要学习SpringBoot"></a>1.2 为什么要学习SpringBoot</h2><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，其原因注意有两点：</p>
<ul>
<li><p>复杂的配置</p>
<p>项目搁置配置其实是开发时的损耗，因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p>
</li>
<li><p>一个是混乱的依赖管理</p>
<p>项目的依赖管理也是件吃力不讨好的事情。觉得项目里要用哪些库就已经让人头疼了，还要知道这些库的哪个版本和其他库会不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写在应用程序代码中。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问回事生产力杀手。</p>
</li>
</ul>
<p>而SpringBoot让这一切成为过去</p>
<blockquote>
<p>Spring Boot简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供了开箱即用的设置（提供默认设置，存放默认配置的包就是启动器Starter），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。</p>
</blockquote>
<p>我们可以使用SpringBoot创建java应用，并使用java -jar启动它，就能得到一个生产级别的web工程。</p>
<h2 id="1-3-SpringBoot的特点"><a href="#1-3-SpringBoot的特点" class="headerlink" title="1.3 SpringBoot的特点"></a>1.3 SpringBoot的特点</h2><p>Spring Boot 主要目标：</p>
<ul>
<li>为所有Spring的开发者提供一个非常快速的、广泛接受的入门体验</li>
<li>开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但是通过自己设置参数（.properties），即可快速摆脱这种方式。</li>
<li>提供了一个大型心目中常见的非功能性特性，如内嵌服务器、安全、指标，健康监测、外部化配置等</li>
</ul>
<h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h1><p>利用SpringBoot搭建一个web工程。</p>
<h2 id="2-1-常见工程"><a href="#2-1-常见工程" class="headerlink" title="2.1 常见工程"></a>2.1 常见工程</h2><p>使用Idea新建一个空的Maven工程：</p>
<h2 id="2-2-添加依赖"><a href="#2-2-添加依赖" class="headerlink" title="2.2 添加依赖"></a>2.2 添加依赖</h2><p>SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用的依赖（报废全部）的版本进行了管理，项目需要以这个项目为父工程，这样就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可。</p>
<h3 id="2-2-1-添加父工程坐标"><a href="#2-2-1-添加父工程坐标" class="headerlink" title="2.2.1 添加父工程坐标"></a>2.2.1 添加父工程坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-添加web启动器"><a href="#2-2-2-添加web启动器" class="headerlink" title="2.2.2 添加web启动器"></a>2.2.2 添加web启动器</h3><p>为了让SpringBoot帮我们完成各种配置，必须引入SpringBoot提供的自动配置依赖，称为启动器。因为是web项目，所以引入web启动器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理。这个时候，会发现项目中多了大量的依赖，这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。</p>
<h3 id="2-2-3-管理jdk版本"><a href="#2-2-3-管理jdk版本" class="headerlink" title="2.2.3 管理jdk版本"></a>2.2.3 管理jdk版本</h3><p>如果需要修改SpringBoot项目的jdk版本，只需要简单的添加一下属性即可，如果没有需求，则不添加。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-4-完整的pom文件"><a href="#2-2-4-完整的pom文件" class="headerlink" title="2.2.4 完整的pom文件"></a>2.2.4 完整的pom文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.longhui.wu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>userservice<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>eureka-server<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>zuul-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="2-3-启动类"><a href="#2-3-启动类" class="headerlink" title="2.3 启动类"></a>2.3 启动类</h2><p>Spring Boot编写Main函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootJpaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootJpaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="2-4-编写controller"><a href="#2-4-编写controller" class="headerlink" title="2.4 编写controller"></a>2.4 编写controller</h2><p>Spring Boot编写controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User  <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        User user = userService.queryById(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="2-5-启动测试"><a href="#2-5-启动测试" class="headerlink" title="2.5 启动测试"></a>2.5 启动测试</h2><p>运行main函数，查看控制台：</p>
<p>并且可以看到监听的端口信息：</p>
<ul>
<li>监听的端口是8080</li>
<li>SpringMVC的映射路径是：/</li>
<li>/user/{id}路径已经映射到userController方法</li>
</ul>
<h1 id="3-Java配置"><a href="#3-Java配置" class="headerlink" title="3.Java配置"></a>3.Java配置</h1><p>使用SpringBoot没有配置任何xml信息，也没有配置Bean，数据库连接池等等。 如今该如何去配置数据源连接池的信息。</p>
<h2 id="3-1-回顾历史"><a href="#3-1-回顾历史" class="headerlink" title="3.1 回顾历史"></a>3.1 回顾历史</h2><p>事实上，在Spring 3.0开始，Spring官方就已经开始推荐使用Java配置来代替传统的xml配置了，回顾一下Spring的历史：</p>
<ul>
<li><p>Spring1.0时代</p>
<p>在此时运维jdl1.5刚刚出来，注解开发并未流行，因此一切Spring配置都是xml格式，所有的bean都用xml配置，工作量很多。</p>
</li>
<li><p>Spring2.0时代</p>
<p>Spring2.0引入了注解开发，都是因为并不完善，因此并没完全替代xml，此时的程序员往往是把xml与注解进行结合。</p>
</li>
<li><p>Spring3.0及以后</p>
<p>3.0以后Spring注解已经很完善，因此Spring推荐使用完全的java配置来替代以前的xml，但是并没有推广流行。直到SpringBoot的流行。</p>
</li>
</ul>
<h2 id="3-2-尝试java配置"><a href="#3-2-尝试java配置" class="headerlink" title="3.2 尝试java配置"></a>3.2 尝试java配置</h2><p>java配置主要靠java类和一些注解，比较常用的注解有：</p>
<ul>
<li>@Configuration：声明一个类作为配置类，代替xml文件</li>
<li>@Bean：声明在方法上，将方法的返回值加入Bean容器，代替<bean>标签</li>
<li>@value：属性注入</li>
<li>@PropertySource：指定外部属性文件</li>
</ul>
<p>尝试使用java配置来实现数据库连接池配置</p>
<p>首先引入Druid连接池依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建一个jdbc.properties文件，编写jdbc属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MySQL</span></span><br><span class="line"><span class="meta">MySQL.jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">MySQL.jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/springboot_mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">MySQL.jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">MySQL.jdbc.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">MySQL.jdbc.validationQuery</span>=<span class="string">select now()</span></span><br></pre></td></tr></table></figure>
<p>然后编写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.userName&#125;&quot;)</span></span><br><span class="line">    String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;password&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUserName(userName);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-3-SpringBoot的属性注入"><a href="#3-3-SpringBoot的属性注入" class="headerlink" title="3.3 SpringBoot的属性注入"></a>3.3 SpringBoot的属性注入</h2><p>属性文件的名称有变化，默认的文件名必须要是：application.properties或application.yml</p>
<p>java注解中，使用的是@Value注解。这种方式虽然可以行，但是不够强大，因为它只能够注入一些基本类型。</p>
<p>在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型和复杂类型的注入。</p>
<p>1）新建一个类，用来进行属性注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfiguretionProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    `````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在类上通过@ConfigurationProperties注解声明当前类为属性读取类</li>
<li>prefix=“jdbc”读取属性文件中，前缀为jdbc的值</li>
<li>在类上定义各个属性，名称必须与属性文件中的名称一致</li>
<li>需要注意的是，这里并没有指定属性文件的地址，所以需要把jdbc.properties名称改为application.properties.这是SpringBoot默认读取的属性文件名</li>
</ul>
<p>2）在jdbcConfig中使用这个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuretion</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dateSource</span><span class="params">(JdbcProperties.class)</span></span>&#123;</span><br><span class="line">        ````略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象</p>
</li>
<li><p>然后可以通过以下的方式注入JdbcProperties</p>
<p>@Autowired注入</p>
<p>@构造函数注入</p>
<p>@声明有@Bean的方法参数注入</p>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分布式技术</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 远程控制管理</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/01.Linux/02.Linux%20%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Linux-远程控制管理"><a href="#Linux-远程控制管理" class="headerlink" title="Linux 远程控制管理"></a>Linux 远程控制管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>传统的网络服务程序，FTP、POP、telnet 本质上都是不安全的，因为它们在网络上通过明文传送口令和数据，这些数据非常容易被截获。SSH 叫做 <code>Secure Shell</code>。通过 SSH，可以把传输数据进行加密，预防攻击，传输的数据进行了压缩，可以加快传输速度。</p>
<h2 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h2><p>SSH 是芬兰一家公司开发。但是受到版权和加密算法限制，现在很多人都使用 OpenSSH。OpenSSH 是 SSH 的替代软件，免费。</p>
<p>OpenSSH 由客户端和服务端组成。</p>
<ul>
<li>基于口令的安全验证：知道服务器的帐号密码即可远程登录，口令和数据在传输过程中都会被加密。</li>
<li>基于密钥的安全验证：此时需要在创建一对密钥，把公有密钥放到远程服务器上自己的宿主目录中，而私有密钥则由自己保存。</li>
</ul>
<h3 id="检查软件是否安装"><a href="#检查软件是否安装" class="headerlink" title="检查软件是否安装"></a>检查软件是否安装</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apt-cache policy openssh-client openssh-server</span><br></pre></td></tr></table></figure>
<h3 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server</span><br></pre></td></tr></table></figure>


<h3 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-client</span><br></pre></td></tr></table></figure>
<p>OpenSSH 服务器的主要配置文件为 <code>/etc/ssh/sshd\_config</code>，几乎所有的配置信息都在此文件中。</p>
<h2 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h2><p>XShell 是一个强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。XShell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。</p>
<p>XShell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。</p>
]]></content>
      <categories>
        <category>计算器基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算器基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 简介</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/01.Linux/01.Linux%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。</p>
<p>Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution</p>
<p>目前市面上较知名的发行版有：<code>Ubuntu</code>、RedHat、<code>CentOS</code>、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p>
<h2 id="Linux-与-Windows-比较"><a href="#Linux-与-Windows-比较" class="headerlink" title="Linux 与 Windows 比较"></a>Linux 与 Windows 比较</h2><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p>
<table>
<thead>
<tr>
<th align="left">比较</th>
<th align="left">Windows</th>
<th align="left">Linux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">界面</td>
<td align="left">界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td>
<td align="left">图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td>
</tr>
<tr>
<td align="left">驱动程序</td>
<td align="left">驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td>
<td align="left">由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td>
</tr>
<tr>
<td align="left">使用</td>
<td align="left">使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td>
<td align="left">图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td>
</tr>
<tr>
<td align="left">学习</td>
<td align="left">系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td>
<td align="left">系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td>
</tr>
<tr>
<td align="left">软件</td>
<td align="left">每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td>
<td align="left">大部分软件都可以自由获取，同样功能的软件选择较少。</td>
</tr>
</tbody></table>
<h2 id="安装-Ubuntu-Server"><a href="#安装-Ubuntu-Server" class="headerlink" title="安装 Ubuntu Server"></a>安装 Ubuntu Server</h2><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>原生云应用基本都是基于云服务器部署，本地化的 Linux 操作基本也都是在虚拟机中进行模拟操作。故我们只需要安装虚拟机并在虚拟机上安装对应的 Linux 操作系统即可。</p>
<h3 id="安装-VMware"><a href="#安装-VMware" class="headerlink" title="安装 VMware"></a>安装 VMware</h3><p>不提供具体的安装说明，请自行查阅相关资料</p>
<h3 id="安装-Ubuntu-Server-1"><a href="#安装-Ubuntu-Server-1" class="headerlink" title="安装 Ubuntu Server"></a>安装 Ubuntu Server</h3><p>百度</p>
]]></content>
      <categories>
        <category>计算器基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算器基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 的目录结构</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/01.Linux/03.Linux%20%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="./assets/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171102134832.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">目录</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bin</td>
<td align="left">存放二进制可执行文件(ls,cat,mkdir等)</td>
</tr>
<tr>
<td align="left">boot</td>
<td align="left">存放用于系统引导时使用的各种文件</td>
</tr>
<tr>
<td align="left">dev</td>
<td align="left">用于存放设备文件</td>
</tr>
<tr>
<td align="left">etc</td>
<td align="left">存放系统配置文件</td>
</tr>
<tr>
<td align="left">home</td>
<td align="left">存放所有用户文件的根目录</td>
</tr>
<tr>
<td align="left">lib</td>
<td align="left">存放跟文件系统中的程序运行所需要的共享库及内核模块</td>
</tr>
<tr>
<td align="left">mnt</td>
<td align="left">系统管理员安装临时文件系统的安装点</td>
</tr>
<tr>
<td align="left">opt</td>
<td align="left">额外安装的可选应用程序包所放置的位置</td>
</tr>
<tr>
<td align="left">proc</td>
<td align="left">虚拟文件系统，存放当前内存的映射</td>
</tr>
<tr>
<td align="left">root</td>
<td align="left">超级用户目录</td>
</tr>
<tr>
<td align="left">sbin</td>
<td align="left">存放二进制可执行文件，只有root才能访问</td>
</tr>
<tr>
<td align="left">tmp</td>
<td align="left">用于存放各种临时文件</td>
</tr>
<tr>
<td align="left">usr</td>
<td align="left">用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td>
</tr>
<tr>
<td align="left">var</td>
<td align="left">用于存放运行时需要改变数据的文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算器基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算器基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 操作文件目录</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/01.Linux/04.Linux%20%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Linux-操作文件目录"><a href="#Linux-操作文件目录" class="headerlink" title="Linux 操作文件目录"></a>Linux 操作文件目录</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
<th align="left">语法</th>
<th align="left">参数</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ls</td>
<td align="left">显示文件和目录列表</td>
<td align="left">ls [-alrtAFR] [name…]</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-l</td>
<td align="left">列出文件的详细信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-a</td>
<td align="left">列出当前目录所有文件，包含隐藏文件</td>
</tr>
<tr>
<td align="left">mkdir</td>
<td align="left">创建目录</td>
<td align="left">mkdir [-p] dirName</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-p</td>
<td align="left">父目录不存在情况下先生成父目录</td>
</tr>
<tr>
<td align="left">cd</td>
<td align="left">切换目录</td>
<td align="left">cd [dirName]</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">touch</td>
<td align="left">生成一个空文件</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">echo</td>
<td align="left">生成一个带内容文件</td>
<td align="left">echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">cat</td>
<td align="left">显示文本文件内容</td>
<td align="left">cat [-AbeEnstTuv] [–help] [–version] fileName</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">cp</td>
<td align="left">复制文件或目录</td>
<td align="left">cp [options] source dest</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">rm</td>
<td align="left">删除文件</td>
<td align="left">rm [options] name…</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-f</td>
<td align="left">强制删除文件或目录</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-r</td>
<td align="left">同时删除该目录下的所有文件</td>
</tr>
<tr>
<td align="left">mv</td>
<td align="left">移动文件或目录</td>
<td align="left">mv [options] source dest</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">find</td>
<td align="left">在文件系统中查找指定的文件</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-name</td>
<td align="left">文件名</td>
</tr>
<tr>
<td align="left">grep</td>
<td align="left">在指定的文本文件中查找指定的字符串</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">tree</td>
<td align="left">用于以树状图列出目录的内容</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">pwd</td>
<td align="left">显示当前工作目录</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ln</td>
<td align="left">建立软链接</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">more</td>
<td align="left">分页显示文本文件内容</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">head</td>
<td align="left">显示文件开头内容</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">tail</td>
<td align="left">显示文件结尾内容</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-f</td>
<td align="left">跟踪输出</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算器基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>计算器基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装 MySQL</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/01.Linux/08.Linux%20%E5%AE%89%E8%A3%85%20MySQL/</url>
    <content><![CDATA[<h1 id="Linux-安装-MySQL"><a href="#Linux-安装-MySQL" class="headerlink" title="Linux 安装 MySQL"></a>Linux 安装 MySQL</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="更新数据源"><a href="#更新数据源" class="headerlink" title="更新数据源"></a>更新数据源</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>


<h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apt-get install mysql-server</span><br></pre></td></tr></table></figure>


<p>系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但 Mysql 5.7 已经自动完成了。</p>
<p>运行安全脚本：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>


<p>这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lusifer@ubuntu:~$ systemctl status mysql.service</span><br><span class="line">● mysql.service - MySQL Community Server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago</span><br><span class="line"> Main PID: 2169 (mysqld)</span><br><span class="line">   CGroup: /system.slice/mysql.service</span><br><span class="line">           └─2169 /usr/sbin/mysqld</span><br><span class="line"></span><br><span class="line">Nov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server...</span><br><span class="line">Nov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server.</span><br></pre></td></tr></table></figure>


<p>查看 MySQL 版本：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mysqladmin -p -u root version</span><br></pre></td></tr></table></figure>


<h2 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h2><ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nano /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>


<ul>
<li>注释掉(语句前面加上 # 即可)：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bind-address = 127.0.0.1</span><br></pre></td></tr></table></figure>


<ul>
<li>重启 MySQL</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>


<ul>
<li>登录 MySQL</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>


<ul>
<li>授权 root 用户允许所有人连接</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;你的 mysql root 账户密码&#x27;;</span><br></pre></td></tr></table></figure>


<h3 id="因弱口令无法成功授权解决步骤"><a href="#因弱口令无法成功授权解决步骤" class="headerlink" title="因弱口令无法成功授权解决步骤"></a>因弱口令无法成功授权解决步骤</h3><ul>
<li>查看和设置密码安全级别</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">select @@validate_password_policy;</span><br></pre></td></tr></table></figure>


<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br></pre></td></tr></table></figure>


<ul>
<li>查看和设置密码长度限制</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">select @@validate_password_length;</span><br></pre></td></tr></table></figure>


<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">set global validate_password_length=1;</span><br></pre></td></tr></table></figure>


<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure>


<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>


<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>


<h2 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h2><p>修改配置 <code>mysqld.cnf</code> 配置文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>


<h3 id="配置默认字符集"><a href="#配置默认字符集" class="headerlink" title="配置默认字符集"></a>配置默认字符集</h3><p>在 <code>[mysqld]</code> 节点上增加如下配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>



<p>在 <code>[mysqld]</code> 节点底部增加如下配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure>


<h3 id="配置忽略数据库大小写敏感"><a href="#配置忽略数据库大小写敏感" class="headerlink" title="配置忽略数据库大小写敏感"></a>配置忽略数据库大小写敏感</h3><p>在 <code>[mysqld]</code> 节点底部增加如下配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lower-case-table-names = 1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算器基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
        <tag>计算器基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装 Tomcat</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/01.Linux/07.Linux%20%E5%AE%89%E8%A3%85%20Tomcat/</url>
    <content><![CDATA[<h1 id="Linux-安装-Tomcat"><a href="#Linux-安装-Tomcat" class="headerlink" title="Linux 安装 Tomcat"></a>Linux 安装 Tomcat</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>此处以 Tomcat 8.5.23 为例</p>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></p>
<h2 id="解压缩并移动到指定目录"><a href="#解压缩并移动到指定目录" class="headerlink" title="解压缩并移动到指定目录"></a>解压缩并移动到指定目录</h2><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.23.tar.gz</span><br></pre></td></tr></table></figure>


<h3 id="变更目录名"><a href="#变更目录名" class="headerlink" title="变更目录名"></a>变更目录名</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mv apache-tomcat-8.5.23 tomcat</span><br></pre></td></tr></table></figure>


<h3 id="移动目录"><a href="#移动目录" class="headerlink" title="移动目录"></a>移动目录</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mv tomcat/ /usr/local/</span><br></pre></td></tr></table></figure>


<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/usr/local/tomcat/bin/startup.sh</span><br></pre></td></tr></table></figure>


<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/usr/local/tomcat/bin/shutdown.sh</span><br></pre></td></tr></table></figure>


<h3 id="目录内执行脚本"><a href="#目录内执行脚本" class="headerlink" title="目录内执行脚本"></a>目录内执行脚本</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算器基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tomcat</tag>
        <tag>计算器基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装 Java</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/01.Linux/06.Linux%20%E5%AE%89%E8%A3%85%20Java/</url>
    <content><![CDATA[<h1 id="Linux-安装-Java"><a href="#Linux-安装-Java" class="headerlink" title="Linux 安装 Java"></a>Linux 安装 Java</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>此处以 JDK 1.8.0_152 为例</p>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<h2 id="解压缩并移动到指定目录"><a href="#解压缩并移动到指定目录" class="headerlink" title="解压缩并移动到指定目录"></a>解压缩并移动到指定目录</h2><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>


<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/java</span><br></pre></td></tr></table></figure>


<h3 id="移动安装包"><a href="#移动安装包" class="headerlink" title="移动安装包"></a>移动安装包</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mv jdk1.8.0_152/ /usr/local/java/</span><br></pre></td></tr></table></figure>


<h3 id="设置所有者"><a href="#设置所有者" class="headerlink" title="设置所有者"></a>设置所有者</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">chown -R root:root /usr/local/java/</span><br></pre></td></tr></table></figure>


<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><h3 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nano /etc/environment</span><br></pre></td></tr></table></figure>


<h3 id="添加如下语句"><a href="#添加如下语句" class="headerlink" title="添加如下语句"></a>添加如下语句</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_231</span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.8.0_231/jre</span><br><span class="line">export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure>


<h3 id="配置用户环境变量"><a href="#配置用户环境变量" class="headerlink" title="配置用户环境变量"></a>配置用户环境变量</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nano /etc/profile</span><br></pre></td></tr></table></figure>


<h3 id="添加如下语句-1"><a href="#添加如下语句-1" class="headerlink" title="添加如下语句"></a>添加如下语句</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if [ &quot;$PS1&quot; ]; then</span><br><span class="line">  if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then</span><br><span class="line">    # The file bash.bashrc already sets the default PS1.</span><br><span class="line">    # PS1=&#x27;\h:\w\$ &#x27;</span><br><span class="line">    if [ -f /etc/bash.bashrc ]; then</span><br><span class="line">      . /etc/bash.bashrc</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    if [ &quot;`id -u`&quot; -eq 0 ]; then</span><br><span class="line">      PS1=&#x27;# &#x27;</span><br><span class="line">    else</span><br><span class="line">      PS1=&#x27;$ &#x27;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_231</span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.8.0_231/jre</span><br><span class="line">export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">if [ -d /etc/profile.d ]; then</span><br><span class="line">  for i in /etc/profile.d/*.sh; do</span><br><span class="line">    if [ -r $i ]; then</span><br><span class="line">      . $i</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  unset i</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


<h3 id="使用户环境变量生效"><a href="#使用户环境变量生效" class="headerlink" title="使用户环境变量生效"></a>使用户环境变量生效</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>


<h2 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@UbuntuBase:/usr/local/java# java -version</span><br><span class="line">java version &quot;1.8.0_152&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure>


<h2 id="为其他用户更新用户环境变量"><a href="#为其他用户更新用户环境变量" class="headerlink" title="为其他用户更新用户环境变量"></a>为其他用户更新用户环境变量</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">su lusifer</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算器基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
        <tag>计算器基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 简介</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/02.Docker/01.Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby">GitHub</a> 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/">开放容器联盟（OCI）</a>。</p>
<p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，<a href="https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/">dotCloud 公司决定改名为 Docker</a>。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p>
<p>Docker 使用 Google 公司推出的 <a href="https://golang.org/">Go 语言</a> 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="./assets/virtualization.png" alt="传统虚拟化"></p>
<p><img src="https://www.funtl.com/assets/docker.png" alt="Docker"></p>
<h1 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<h2 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<h2 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h2><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<h2 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h2><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em>这类问题。</p>
<h2 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h2><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <code>Dockerfile</code> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p>
<p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<h2 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h2><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h2 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h2><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://store.docker.com/search?q=&source=verified&type=image">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">容器</th>
<th align="left">虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动</td>
<td align="left">秒级</td>
<td align="left">分钟级</td>
</tr>
<tr>
<td align="left">硬盘使用</td>
<td align="left">一般为 <code>MB</code></td>
<td align="left">一般为 <code>GB</code></td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">接近原生</td>
<td align="left">弱于</td>
</tr>
<tr>
<td align="left">系统支持量</td>
<td align="left">单机支持上千个容器</td>
<td align="left">一般几十个</td>
</tr>
</tbody></table>
<h1 id="Docker-引擎"><a href="#Docker-引擎" class="headerlink" title="Docker 引擎"></a>Docker 引擎</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p>
<ul>
<li>一种服务器，它是一种称为守护进程并且长时间运行的程序。</li>
<li>REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。</li>
<li>一个有命令行界面 (CLI) 工具的客户端。</li>
</ul>
<p>Docker 引擎组件的流程如下图所示：</p>
<p><img src="./assets/620140640_31678.png" alt="img"></p>
<h1 id="Docker-系统架构"><a href="#Docker-系统架构" class="headerlink" title="Docker 系统架构"></a>Docker 系统架构</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<table>
<thead>
<tr>
<th align="left">Docker</th>
<th align="left">面向对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器</td>
<td align="left">对象</td>
</tr>
<tr>
<td align="left">镜像</td>
<td align="left">类</td>
</tr>
</tbody></table>
<p><img src="./assets/262150629_86976.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">标题</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td align="left">容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用。</td>
</tr>
<tr>
<td align="left">客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker API (<a href="https://docs.docker.com/reference/api/docker_remote_api">https://docs.docker.com/reference/api/docker_remote_api</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="left">主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">仓库(Registry)</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:16.04</code> 就包含了完整的一套 Ubuntu 16.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h2 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h2><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code>文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <code>数据卷（Volume）</code>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h1 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code>作为默认标签。</p>
<p>以 <a href="https://store.docker.com/images/ubuntu">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>14.04</code>, <code>16.04</code>。我们可以通过 <code>ubuntu:14.04</code>，或者 <code>ubuntu:16.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h2 id="公有-Docker-Registry"><a href="#公有-Docker-Registry" class="headerlink" title="公有 Docker Registry"></a>公有 Docker Registry</h2><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/">CoreOS</a> 的 <a href="https://quay.io/repository/">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/">Google Container Registry</a>，<a href="http://kubernetes.io/">Kubernetes</a> 的镜像使用的就是这个服务。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/">网易云镜像服务</a>、<a href="https://hub.daocloud.io/">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a> 等。</p>
<h2 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h2><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://store.docker.com/images/registry/">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/">Docker Trusted Registry</a> 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/vmware/harbor">VMWare Harbor</a> 和 <a href="https://www.sonatype.com/docker">Sonatype Nexus</a>。</p>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>分布式技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 安装 Docker</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/02.Docker/02.Ubuntu%20%E5%AE%89%E8%A3%85%20Docker/</url>
    <content><![CDATA[<h1 id="Ubuntu-安装-Docker"><a href="#Ubuntu-安装-Docker" class="headerlink" title="Ubuntu 安装 Docker"></a>Ubuntu 安装 Docker</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote>
<p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.</p>
</blockquote>
<h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>Docker CE 支持以下版本的 <a href="https://www.ubuntu.com/server">Ubuntu</a> 操作系统：</p>
<ul>
<li>Artful 17.10 (Docker CE 17.11 Edge +)</li>
<li>Xenial 16.04 (LTS)</li>
<li>Trusty 14.04 (LTS)</li>
</ul>
<p>Docker CE 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本,当前最新的 LTS 版本为 Ubuntu 16.04。</p>
<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure>


<h3 id="Ubuntu-14-04-可选内核模块"><a href="#Ubuntu-14-04-可选内核模块" class="headerlink" title="Ubuntu 14.04 可选内核模块"></a>Ubuntu 14.04 可选内核模块</h3><p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (<code>linux-image-extra-*</code>) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。<code>AUFS</code> 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 <code>AUFS</code>。</p>
<p>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    linux-image-extra-$(uname -r) \</span><br><span class="line">    linux-image-extra-virtual</span><br></pre></td></tr></table></figure>


<h3 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu 16.04 +"></a>Ubuntu 16.04 +</h3><p>Ubuntu 16.04 + 上的 Docker CE 默认使用 <code>overlay2</code> 存储层驱动,无需手动配置。</p>
<h2 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h2><h3 id="安装必要的一些系统工具"><a href="#安装必要的一些系统工具" class="headerlink" title="安装必要的一些系统工具"></a>安装必要的一些系统工具</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure>


<h3 id="安装-GPG-证书"><a href="#安装-GPG-证书" class="headerlink" title="安装 GPG 证书"></a>安装 GPG 证书</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>


<h3 id="写入软件源信息"><a href="#写入软件源信息" class="headerlink" title="写入软件源信息"></a>写入软件源信息</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure>


<h3 id="更新并安装-Docker-CE"><a href="#更新并安装-Docker-CE" class="headerlink" title="更新并安装 Docker CE"></a>更新并安装 Docker CE</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get -y install docker-ce</span><br></pre></td></tr></table></figure>


<blockquote>
<p>以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新或者测试版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。</p>
</blockquote>
<h2 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"><span class="comment"># 可能会出现 404 错误，请移步下面的特别说明</span></span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>


<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p>
<h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><p>2018 年 7 月 21 日，貌似阿里云这边在做调整，故导致 Docker 的 Aliyun 安装脚本不可用，是永久性还是临时性的尚不清除，如果你已经按照之前的操作安装 Docker，请按以下步骤进行修复并重新安装</p>
<ul>
<li>如果已经使用了 Aliyun 脚本安装并成功的<ul>
<li>请先卸载 Docker，命令为：<code>apt-get autoremove docker-ce</code></li>
<li>删除 <code>/etc/apt/sources.list.d</code> 目录下的 <code>docker.list</code> 文件</li>
</ul>
</li>
<li>使用 <code>AzureChinaCloud</code> 镜像脚本重新安装，命令为：<code>sudo sh get-docker.sh --mirror AzureChinaCloud</code></li>
</ul>
<h2 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>


<p>Ubuntu 14.04 请使用以下命令启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure>
<h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立 <code>docker</code> 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>


<p>将当前用户加入 <code>docker</code> 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>


<p>退出当前终端并重新登录，进行如下测试。</p>
<h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://cloud.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure>


<p>若能正常输出以上信息，则说明安装成功。</p>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 <code>国内镜像加速</code>。</p>
<h1 id="Docker-镜像加速器"><a href="#Docker-镜像加速器" class="headerlink" title="Docker 镜像加速器"></a>Docker 镜像加速器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>
<ul>
<li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror">Docker 官方提供的中国 registry mirror</a></li>
<li><a href="https://cr.console.aliyun.com/#/accelerator">阿里云加速器</a></li>
<li><a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud 加速器</a></li>
</ul>
<p>我们以 Docker 官方加速器为例进行介绍。</p>
<h2 id="Ubuntu-14-04、Debian-7-Wheezy"><a href="#Ubuntu-14-04、Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04、Debian 7 Wheezy"></a>Ubuntu 14.04、Debian 7 Wheezy</h2><p>对于使用 <a href="http://upstart.ubuntu.com/">upstart</a> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中配置加速器地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&quot;--registry-mirror=https://registry.docker-cn.com&quot;</span></span><br></pre></td></tr></table></figure>


<p>重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>


<h2 id="Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="Ubuntu 16.04+、Debian 8+、CentOS 7"></a>Ubuntu 16.04+、Debian 8+、CentOS 7</h2><p>对于使用 <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
</blockquote>
<p>之后重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意：如果您之前查看旧教程，修改了 <code>docker.service</code> 文件内容，请去掉您添加的内容（<code>--registry-mirror=https://registry.docker-cn.com</code>），这里不再赘述。</p>
</blockquote>
<h2 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h2><p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 <code>Settings</code>，打开配置窗口后左侧导航菜单选择 <code>Daemon</code>。在 <code>Registry mirrors</code> 一栏中填写加速器地址 <code>https://registry.docker-cn.com</code>，之后点击 <code>Apply</code> 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><p>对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 <code>https://registry.docker-cn.com</code>。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。</p>
<h2 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h2><p>配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 <code>docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Ubuntu</tag>
        <tag>分布式技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/02.Docker/04.Docker%20%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><h2 id="操作-Docker-容器"><a href="#操作-Docker-容器" class="headerlink" title="操作 Docker 容器"></a>操作 Docker 容器</h2><p>容器是 Docker 又一核心概念。</p>
<p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>


<p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>


<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@af8bae53bdd3:/<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/<span class="comment"># ls</span></span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>


<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code>或 <code>top</code> 来查看进程信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ba267838cc1b:/<span class="comment"># ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   11 ?        00:00:00 ps</span><br></pre></td></tr></table></figure>


<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run ubuntu:17.10 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>


<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d ubuntu:17.10 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure>


<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:17.10  /bin/sh -c &#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></pre></td></tr></table></figure>


<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>


<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:14.04             <span class="string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   <span class="string">&quot;python app.py&quot;</span>        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure>


<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h3><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">$ docker attach 243c</span><br><span class="line">root@243c32535da7:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>


<p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h3><h4 id="i-t-参数"><a href="#i-t-参数" class="headerlink" title="-i -t 参数"></a>-i -t 参数</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>


<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>分布式技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 仓库</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/02.Docker/05.Docker%20%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h1><h2 id="访问-Docker-仓库"><a href="#访问-Docker-仓库" class="headerlink" title="访问 Docker 仓库"></a>访问 Docker 仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a href="https://cloud.docker.com/">https://cloud.docker.com</a> 免费注册一个 Docker 账号。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>例如以 <code>centos</code> 为关键词进行搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br></pre></td></tr></table></figure>


<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p>
<p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p>
<p>根据是否是官方提供，可将镜像资源分为两类。</p>
<p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p>
<p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p>
<p>下载官方 <code>centos</code> 镜像到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">Pulling repository centos</span><br><span class="line">0b443ba03958: Download complete</span><br><span class="line">539c0211cd76: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">7064731afe90: Download complete</span><br></pre></td></tr></table></figure>


<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker tag ubuntu:17.10 username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   17.10                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          17.10                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">$ docker search username</span><br><span class="line"></span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure>


<h3 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h3><p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p>
<p>有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。</p>
<p>而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 <a href="https://github.com/">GitHub</a> 或 <a href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交或者创建新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动创建，包括如下的步骤：</p>
<ul>
<li>创建并登录 Docker Hub，以及目标网站；</li>
<li>在目标网站中连接帐户到 Docker Hub；</li>
<li>在 Docker Hub 中 <a href="https://registry.hub.docker.com/builds/add/">配置一个自动创建</a>；</li>
<li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li>
<li>指定 <code>Dockerfile</code> 的位置，并提交创建。</li>
</ul>
<p>之后，可以在 Docker Hub 的 <a href="https://registry.hub.docker.com/builds/">自动创建页面</a> 中跟踪每次创建的状态。</p>
<h2 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p>本节介绍如何使用本地仓库。</p>
<p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p>
<h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><h4 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h4><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure>


<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>


<h3 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p>
<p>先在本机查看已有的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>


<p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p>
<p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>


<p>使用 <code>docker push</code> 上传标记的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure>


<p>用 <code>curl</code> 查看仓库中的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;ubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>


<p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p>
<p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>


<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<h4 id="Ubuntu-14-04-Debian-7-Wheezy"><a href="#Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04, Debian 7 Wheezy"></a>Ubuntu 14.04, Debian 7 Wheezy</h4><p>对于使用 <code>upstart</code> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中增加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&quot;--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000&quot;</span></span><br></pre></td></tr></table></figure>


<p>重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>


<h4 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;192.168.199.100:5000&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于 Docker for Windows 、 Docker for Mac 在设置中编辑 <code>daemon.json</code> 增加和上边一样的字符串即可。</p>
]]></content>
      <categories>
        <category>分布式技术</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>分布式技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 实战</title>
    <url>/2021/02/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/00.%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/02.Docker/06.Docker%20%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="Docker-实战"><a href="#Docker-实战" class="headerlink" title="Docker 实战"></a>Docker 实战</h1><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p>
</blockquote>
<h3 id="选择-v-还是-–mount-参数"><a href="#选择-v-还是-–mount-参数" class="headerlink" title="选择 -v 还是 -–mount 参数"></a>选择 -v 还是 -–mount 参数</h3><p>Docker 新用户应该选择 <code>--mount</code> 参数，经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟悉了，但是推荐使用 <code>--mount</code> 参数。</p>
<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure>


<p>查看所有的 <code>数据卷</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure>


<p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/wepapp \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure>


<h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure>
<p>1</p>
<p><code>数据卷</code> 信息在 “Mounts” Key 下面</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Destination&quot;</span>: <span class="string">&quot;/app&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>


<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure>


<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code>这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>


<h2 id="Docker-构建-Tomcat"><a href="#Docker-构建-Tomcat" class="headerlink" title="Docker 构建 Tomcat"></a>Docker 构建 Tomcat</h2><h3 id="查找-Docker-Hub-上的-Tomcat-镜像"><a href="#查找-Docker-Hub-上的-Tomcat-镜像" class="headerlink" title="查找 Docker Hub 上的 Tomcat 镜像"></a>查找 Docker Hub 上的 Tomcat 镜像</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@UbuntuBase:/usr/local/docker/tomcat# docker search tomcat</span><br><span class="line">NAME                           DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">tomcat                         Apache Tomcat is an open source implementa...   1550                [OK]                </span><br><span class="line">dordoka/tomcat                 Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 ba...   43                                      [OK]</span><br><span class="line">tomee                          Apache TomEE is an all-Apache Java EE cert...   42                  [OK]                </span><br><span class="line">davidcaste/alpine-tomcat       Apache Tomcat 7/8 using Oracle Java 7/8 wi...   21                                      [OK]</span><br><span class="line">consol/tomcat-7.0              Tomcat 7.0.57, 8080, &quot;admin/admin&quot;              16                                      [OK]</span><br><span class="line">cloudesire/tomcat              Tomcat server, 6/7/8                            15                                      [OK]</span><br><span class="line">maluuba/tomcat7                                                                9                                       [OK]</span><br><span class="line">tutum/tomcat                   Base docker image to run a Tomcat applicat...   8                                       </span><br><span class="line">jeanblanchard/tomcat           Minimal Docker image with Apache Tomcat         8                                       </span><br><span class="line">andreptb/tomcat                Debian Jessie based image with Apache Tomc...   7                                       [OK]</span><br><span class="line">bitnami/tomcat                 Bitnami Tomcat Docker Image                     5                                       [OK]</span><br><span class="line">aallam/tomcat-mysql            Debian, Oracle JDK, Tomcat &amp; MySQL              4                                       [OK]</span><br><span class="line">antoineco/tomcat-mod_cluster   Apache Tomcat with JBoss mod_cluster            1                                       [OK]</span><br><span class="line">maluuba/tomcat7-java8          Tomcat7 with java8.                             1                                       </span><br><span class="line">amd64/tomcat                   Apache Tomcat is an open source implementa...   1                                       </span><br><span class="line">primetoninc/tomcat             Apache tomcat 8.5, 8.0, 7.0                     1                                       [OK]</span><br><span class="line">trollin/tomcat                                                                 0                                       </span><br><span class="line">fabric8/tomcat-8               Fabric8 Tomcat 8 Image                          0                                       [OK]</span><br><span class="line">awscory/tomcat                 tomcat                                          0                                       </span><br><span class="line">oobsri/tomcat8                 Testing CI Jobs with different names.           0                                       </span><br><span class="line">hegand/tomcat                  docker-tomcat                                   0                                       [OK]</span><br><span class="line">s390x/tomcat                   Apache Tomcat is an open source implementa...   0                                       </span><br><span class="line">ppc64le/tomcat                 Apache Tomcat is an open source implementa...   0                                       </span><br><span class="line">99taxis/tomcat7                Tomcat7                                         0                                       [OK]</span><br><span class="line">qminderapp/tomcat7             Tomcat 7                                        0</span><br></pre></td></tr></table></figure>


<p>这里我们拉取官方的镜像</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>


<p>等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 tomcat 的镜像。</p>
<h3 id="运行容器："><a href="#运行容器：" class="headerlink" title="运行容器："></a>运行容器：</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">docker run --name tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat</span><br></pre></td></tr></table></figure>


<p>命令说明：</p>
<ul>
<li>-p 8080:8080：将容器的8080端口映射到主机的8080端口</li>
<li>-v $PWD/test:/usr/local/tomcat/webapps/test：将主机中当前目录下的test挂载到容器的/test</li>
</ul>
<p>查看容器启动情况</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@UbuntuBase:/usr/local/docker/tomcat/webapps# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">38498e53128c        tomcat              &quot;catalina.sh run&quot;   2 minutes ago       Up 2 minutes        0.0.0.0:8080-&gt;8080/tcp   tomcat</span><br></pre></td></tr></table></figure>


<p>通过浏览器访问</p>
<p><img src="./assets/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171103174843.png" alt="img"></p>
<h2 id="Docker-构建-MySQL"><a href="#Docker-构建-MySQL" class="headerlink" title="Docker 构建 MySQL"></a>Docker 构建 MySQL</h2><h3 id="查找-Docker-Hub-上的-MySQL-镜像"><a href="#查找-Docker-Hub-上的-MySQL-镜像" class="headerlink" title="查找 Docker Hub 上的 MySQL 镜像"></a>查找 Docker Hub 上的 MySQL 镜像</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">root@UbuntuBase:/usr/local/docker/mysql# docker search mysql</span><br><span class="line">NAME                                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                                                  MySQL is a widely used, open-source relati...   5177                [OK]                </span><br><span class="line">mariadb                                                MariaDB is a community-developed fork of M...   1602                [OK]                </span><br><span class="line">mysql/mysql-server                                     Optimized MySQL Server Docker images. Crea...   361                                     [OK]</span><br><span class="line">percona                                                Percona Server is a fork of the MySQL rela...   298                 [OK]                </span><br><span class="line">hypriot/rpi-mysql                                      RPi-compatible Docker Image with Mysql          72                                      </span><br><span class="line">zabbix/zabbix-server-mysql                             Zabbix Server with MySQL database support       62                                      [OK]</span><br><span class="line">centurylink/mysql                                      Image containing mysql. Optimized to be li...   53                                      [OK]</span><br><span class="line">sameersbn/mysql                                                                                        48                                      [OK]</span><br><span class="line">zabbix/zabbix-web-nginx-mysql                          Zabbix frontend based on Nginx web-server ...   36                                      [OK]</span><br><span class="line">tutum/mysql                                            Base docker image to run a MySQL database ...   27                                      </span><br><span class="line">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5   ubuntu-16-nginx-php-phpmyadmin-mysql-5          17                                      [OK]</span><br><span class="line">schickling/mysql-backup-s3                             Backup MySQL to S3 (supports periodic back...   16                                      [OK]</span><br><span class="line">centos/mysql-57-centos7                                MySQL 5.7 SQL database server                   15                                      </span><br><span class="line">linuxserver/mysql                                      A Mysql container, brought to you by Linux...   12                                      </span><br><span class="line">centos/mysql-56-centos7                                MySQL 5.6 SQL database server                   6                                       </span><br><span class="line">openshift/mysql-55-centos7                             DEPRECATED: A Centos7 based MySQL v5.5 ima...   6                                       </span><br><span class="line">frodenas/mysql                                         A Docker Image for MySQL                        3                                       [OK]</span><br><span class="line">dsteinkopf/backup-all-mysql                            backup all DBs in a mysql server                3                                       [OK]</span><br><span class="line">circleci/mysql                                         MySQL is a widely used, open-source relati...   2                                       </span><br><span class="line">cloudposse/mysql                                       Improved `mysql` service with support for ...   0                                       [OK]</span><br><span class="line">astronomerio/mysql-sink                                MySQL sink                                      0                                       [OK]</span><br><span class="line">ansibleplaybookbundle/rhscl-mysql-apb                  An APB which deploys RHSCL MySQL                0                                       [OK]</span><br><span class="line">cloudfoundry/cf-mysql-ci                               Image used in CI of cf-mysql-release            0                                       </span><br><span class="line">astronomerio/mysql-so